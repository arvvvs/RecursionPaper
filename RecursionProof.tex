\documentclass{article}
\usepackage{verbatim}
\usepackage{listings}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{mathtools}
\newcommand{\itab}[1]{\hspace{0em}\rlap{#1}}
\newcommand{\tab}[1]{\hspace{.2\textwidth}\rlap{#1}}
\begin{document}

\title{Recursion and Applications}
\author{Akshay Raj Verma}
\maketitle
{Definition.} A method of defining functions in which the function is being defined is applied by it's own definition
\\
Methods that exhibit recursive behavior can be defined by two properties: \\
\begin{enumerate}
	\item A base case (or cases)
	\item An algorithm which is used to solve instances of smaller problems, using the solution and the algorithm to solve the original problem
\end{enumerate}
{\bf Example:} The Fibonacci Sequence is a famous example of a recursive function\\
\hspace{10mm}{\bf Base Case:}  \hspace{10mm}$f_0=0$ and $f_1=1$
\\
\hspace{10mm}{\bf Formula:} \hspace{11mm} $f(n)=f(n-1)+f(n-2)$ for all $\mathbb{N}$ $ n \geq 2$
\\
{\bf Implementation:}
\\
\begin{center}
$f(0)=0$
\\
$f(1)=1$
\\
$f(2)=f(2-1)+f(2-2)=f(1)+f(0)=1$
\\
$f(3)=f(3-1)+f(3-2)=f(2)+f(1)=2$
\\
$f(4)=f(4-1)+f(4-2)=f(3)+f(2)=3$
\\
$f(5)=f(5-1)+f(5-2)=f(4)+f(3)=5$
\\
$...$
\\
\end{center}
As shown by the above sequences solving $f(2)$ requires the solution for $f(1)$ and $f(0)$.  Once you have the solution to both of them, you apply the Fibonnaci Formula to get $f(2)$.  This process is again repeated for $f(3)$ which requires the solutions to $f(2)$ which in turn as noted above requires $f(1)$ and $f(0)$.  The Fibonacci Formula is again used to solve it, and so on.  
\\
We can see the use of recursion in the Fibonacci Sequence in the procedure when in order to solve the Fibonacci Sequence for $n$ when we invoke the procedure in order to solve the problem itself.   
\\
In conclusion in order to solve the Fibonacci Sequence for f(n+2) using the recursive algorithm above is not possible without first knowing the solutions for f(n+1) and f(n), and calls the Fibonacci formula $n+1$ times to be solved.  
\\
However the nth sequence of the Fibonacci Sequence can also be produced by Binet's formula.
\\
\\
{\bf Theorem:} For all n in $\mathbb{N}$ the Fibonacci Number, we denote $F_n$, can be given directly by the Binet Formula($B_n$) as given below:
\\
\begin{center}
	$B_n=\frac{1}{\sqrt[]{5}}((\frac{1+\sqrt[]{5}}{2})^n-(\frac{1-\sqrt[]{5}}{2})^n)$
\end{center}
~\\
{\bf Proof:} We will prove Binet's Formula through the use of strong induction.
\\
{\bf Lemma 1.} 
If $B_n=F_n$, then for the base cases n=0, 1 $F_0=B_0$ and $F_1=B_1$  
\\
{\bf Proof.}
\\
	We want to show that $B_0=F_0$ and $B_1=F_1$
	\\
	For base case $n=0$:
	\\
	First we substitute $0$ for $n$ $B_0=\frac{1}{\sqrt[]{5}}((\frac{1+\sqrt[]{5}}{2})^0-(\frac{1-\sqrt[]{5}}{2})^0)$
	\\
	Which is equal to $\frac{1}{\sqrt[]{5}}((1)-(1))$
	\\
	Therefore $B_0=0$
	\\
	And so by the Transitive Property $B_0=F_0$
	\\
	For base case $n=1$:
	\\
	First we substitute $1$ for $n$ $B_1=\frac{1}{\sqrt[]{5}}((\frac{1+\sqrt[]{5}}{2})^1-(\frac{1-\sqrt[]{5}}{2})^1)$
	\\
	So $\frac{1}{\sqrt[]{5}}((\frac{1+\sqrt[]{5}}{2})-(\frac{1-\sqrt[]{5}}{2}))$
	\\
	Which is equal to $\frac{1}{\sqrt[]{5}}(\frac{(1+\sqrt[]{5})-(1-\sqrt[]{5})}{2})$
	\\
	Therefore $=\frac{1}{\sqrt[]{5}}(\frac{2*\sqrt[]{5}}{2})$
	\\
	Simplifying further $=\frac{1}{\sqrt[]{5}}(\sqrt[]{5})$
	\\
	Therefore $B_1=1$ 
	\\
	And so by the Transitive Propert $B_1=F_1$


	For Base Cases $n=0$ and $n=1$, Binet's Formula is true.  
$\blacksquare$\\
{\bf Lemma 2.}1
If Binet's Formula is true for all $k \in {\mathbb N}$ then it is true for $k+1$, for $k>1$.
\\
{\bf Proof.}
\\
To demonstrate Binet's Formula is true for k+1 we must demonstrate that:
\begin{center}
	$F_{k+1}=B_{k+1}$
	\\
	Which is equal to $\frac{1}{\sqrt[]{5}}((\frac{1+\sqrt[]{5}}{2})^{k+1}-(\frac{1-\sqrt[]{5}}{2})^{k+1})$
\end{center}
We can rewrite Binet's Formula in terms of $\alpha$ and $\beta$.  $\alpha = \frac{1+\sqrt[]{5}}{2}$ and $\beta = \frac{1-\sqrt[]{5}}{2}$. $\alpha$ can be recognized also as the Golden Ratio.   \\
Substituting in $\alpha$ and $\beta$ into Binet's Formula: \begin{center}$B_n=\frac{\alpha^n - \beta^n}{\sqrt[]{5}}$\end{center}
~\\
{\bf Lemma 2.1.} $\alpha+1 = \alpha^{2}$ and $\beta+1=\beta^{2}$ 
\\
{\bf Proof.}
In order to solve Lemma 2 we want to show that $\alpha+1$=$\alpha^2$ and $\beta+1=\beta^{2}$
\begin{center}
	$\alpha+1= \frac{1+\sqrt[]{5}}{2}+1$
	$=\frac{1+\sqrt[]{5}}{2}+\frac{2}{2}$
	$=\frac{3+\sqrt[]{5}}{2}$
	\\
	$\alpha^{2} = (\frac{1+\sqrt[]{5}}{2})^{2}$
	$=\frac{1+2\sqrt[]{5}+5}{4}$
	$=\frac{6+2\sqrt[]{5}}{4}$
	$=\frac{3+\sqrt[]{5}}{2}$
	\\
	~\\
	So by the transitive property $\alpha^2 = \alpha+1$
	~\\
	$\beta+1 = \frac{1-\sqrt[]{5}}{2}+1$
	$=\frac{1-\sqrt[]{5}}{2}+\frac{2}{2}$
	$=\frac{3-\sqrt[]{5}}{2}$
	\\
	$\beta^{2} = (\frac{1+\sqrt[]{5}}{2})^{2}$
	$=\frac{1-2\sqrt[]{5}+5}{4}$
	$=\frac{6-2\sqrt[]{5}}{4}$
	$=\frac{3-\sqrt[]{5}}{2}$
	\\
	~\\
	So by the transitive property $\beta^2 = \beta+1$$\blacksquare$

\end{center}


{\bf Conclusion} Now we continue with the proof of Lemma 2.1, and we proceed using the defintion of Fibonnaci sequence and induction.
\begin{center}
	$F_{k+1}=F_{k}+F_{k-1}$
	\\
	$
	=\frac{1}{\sqrt[]{5}}(\alpha^k-\beta^k)+\frac{1}{\sqrt[]{5}}(\alpha^{k-1}-\beta^{k-1})
$
\\
$
=
\frac{1}{\sqrt[]{5}}(\alpha^k-\beta^k-\beta^k-\beta^{k-1})
$
\\
$=\frac{1}{\sqrt[]{5}}(\alpha^{k-1}(\alpha+1)-\beta^{k-1}(\beta+1))$
\\
$=\frac{1}{\sqrt[]{5}}(\alpha^{k-1}\alpha^{2}-\beta^{k-1}\beta^2)$
\\
Using Lemma 2.1
$=\frac{1}{\sqrt[]{5}}(\alpha^{k+1}-\beta^{k+1}$)
\\
\end{center}
Using the Principle of induction we have shown that $B_n=F_n$ for all $n \in {\mathbb N}$, by proving the Base Cases of n=0 and n=1, then using induction we found that the theory is true for all $n \in {\mathbb N}$ for all $n>1$, by applying the recursive definition of the Fibonacci sequence.   
$\blacksquare$
\\
~\\
~\\
{\bf Conclusions:} While both formulas for the Fibonacci series give the same resultsfor $n$, from the defintion of computational mathematics they are very different. To find Fibinocci series recursively using $F_n$ requires $n-1$ sums or $O(n)$ time in big O notation. To computationally find the solution to $n$ using Binet's Formula would actually takes longer in cases where $n$ is a relatively small number due to the relative complexity of Binet's Formula.  However to find the Fibonnaci Number for a large $n$ it is faster to use Binet's Formula. The recursive defintion for the Fibonnaci Sequence however is much more efficient if one wishes to find the Fibonnaci Numbers in traversal order from $1$ to $n$.      
\\
\begin{comment}
	ToDo: Factorials, Other math stuff (like Catlan numbers) glanced over, Finally Computer Science implementation,Other applications: in nature Fractals
	also: recursive humor, recursive acronym: discuss recursion in languages?
\end{comment}
\\
{\bf Example} Factorials are another example of a recursive function defined as $n!$ for all nonnegative $\mathbb{Z}$
\\
{\bf Base Case} $n=1$, where the factoral of $1$ (denoted $1!)$, is$ 1$.
One can argue that $0!$ is another base case but the $0!=1$ so it is inconsequential. 
\\
{\bf Formula} $n! = n * (n-1)!$ for all non negative $\mathbb{Z}$ 
\\
{\bf Implementation} \\
\begin{center}
	1!=1
	\\
	2!=2*1!=2
	\\
	3!=3*2!=6
	\\
	4!=4*3!=24
	\\
	5!=5*4!=120
	\\
	6!=6*5!=720
	\\
	...

\end{center}
~\\
Factorials can be defined as the product of all positive $\mathbb{Z}$ less than $n$. In the factorials you can see recursion solving instances of smaller problems when the factorial of $k$ is computed by finding out the factorials of smaller positive $\mathbb{Z}$, like $(k-1)$. And unlike the Fibonacci Sequence, Factorial's base case, when $n=1$, is their "terminating condition".    \\
The "terminating condition" in a recursive sequence is the point where the recursive process ends, so that the recursion doesn't become an infinite recursion.  
{\bf Applications in Computer Science}
\\

Recursion is an important element in computer science. Not only can it be used to solve mathematical problems like Factorials, the Fibinocci Sequence but it is also used to create Data Structures to store information, or search through some structures. 
\\Below is a program written in Pseudocode to compute factorials:
\begin{center}
	{\bf function:} factorial
	\\
	{\bf input:} an non negative integer n whose factorial will be computed
	\\
	{\bf output:} print factorial(n)
	\begin{enumerate}
	
		\item if n is 0 return 1
		\item else return ($n * factorial(n-1)$)
	\end{enumerate}
\end{center}
~\\
{\bf Step by Step Computing for $n=4$}
One way to imagine recursion in Computer Science is like a stack of coins. Each time the function factorial is called a new "coin" is placed on top of the stack. Each "coin" is a version of the function being called except different data is being used.  When n=0 however we instead begin to remove the coins, as now the function is no longer being called rather it is returning data. We begin to "remove" the coins, one by one as each coin now "returns" the data instead of calling the function and cotinues to do so until no more "coins" are left.
\\
A step by step version of the program is shown below:
\begin{enumerate}
	\item $n=4$ so $4* factorial(n-1)$
	\item $n=3$ so $3* factorial(n-1)$
	\item $n=2$ so $2* factorial(n-1)$
	\item $n=1$ so $1* factorial(n-1)$
	\item $n=0$ so $return 1$
	\item Now $n=0$ and no more functions are being called 
	\item return $1*1$
	\item return $2*1$
	\item return $3*2$
	\item return $6*4$
	\item print $24$
\end{enumerate}
~\\A similar program can be written to solve the recursive version of Fibonacci Sequence.  
\\
{\bf Writing a program to solve the Fibonacci Sequence}
\\
Below is a program written in the programming language C to solve the Fibonacci Sequence 
\\
\begin{lstlisting}
	/* Input: non negative integer n.
	Output: Fibonacci Number for n.
	*/
	int fibonacci(int n)
		if(n=0)
			return 0;
		else if(n=1)
			return 1;
		else
			return(fibonacci(n-1)+fibonacci(n-2));
\end{lstlisting}
		
	
\begin{comment}
n=4
f(3)f(2)
f(
\end{comment}
~\\
As we can see in the program above the function fibonacci, unlike the function factorial, is beinged called to return two seperate times: once to calculate the fibonacci number for $n-1$ and again to calculate the fibonacci number for $n-2$.  The function call to $fibonacci$ is repeated until $n=0$,and $n=1$ are called.    

~\\A simple data structure which relies on recursion to store data is the linked list.  The Linked List can be best imagined as a series of boxes (called nodes) which contains three things: the data, and two "pointer" to the next and previous boxes (often called the left and the right pointers). Suppose you need to find information on a someone named Jim. If no such information exists you have to create a box with the data "Jim". The program has no idea how many nodes they are or where the "Jim" box is. So a function a simple function is created to traverse the linked list called "searchJim"that looks at the data in each box.  If Jim does not exist you simply call the function again, except this time telling it to look at the next box(the box to the right), until either Jim is found or the program stops as the next node contains nothing. If the the node cotains nothing then create a new box or "node" containing the data Jim, and have the last nodes right pointer "point" to the newly created node and the "Jim box" left pointer point to the previous box.                 	
\\
The linked list is a relatively simple data structure.  However it is the foundation for more complex data structures such as the Binary Search Tree.





\end{document}

